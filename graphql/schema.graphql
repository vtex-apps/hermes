# To really understand GraphQL, go to http://graphql.org/guide/

type ClientProfileData {
  corporateDocument: String
  corporateName: String
  corporatePhone: String
  customerClass: String
  document: String
  documentType: String
  email: String!
  firstName: String
  id: String!
  isCorporate: Boolean
  lastName: String
  phone: String
  stateInscription: String
  tradeName: String
  userProfileId: String
}

type Item {
  seller: String!
  quantity: Int!
  description: String
  ean: String
  refId: String
  id: String
  productId: String
  sellingPrice: Int!
  price: Int!
  imageUrl: String
  skuName: String
  name: String!
}

type CommentCreatedBy {
  id: String!
  name: String!
  email: String
  key: String
}

type CommentTarget {
  id: String!
  type: String
  url: String
}

type Comment {
  createdBy: CommentCreatedBy
  creationDate: String!
  description: String!
  domain: String!
  id: String!
  lastUpdate: String
  owner: String
  target: CommentTarget
}

type Address {
  addressId: String!
  addressType: String!
  receiverName: String
  street: String!
  number: String!
  complement: String
  neighborhood: String!
  postalCode: String!
  city: String!
  state: String!
  country: String!
  reference: String
  geoCoordinates: [Float]
}

type PickupStoreInfo {
  additionalInfo: String
  address: Address
  dockId: String
  friendlyName: String
  isPickupStore: Boolean!
}

type DeliveryId {
  courierId: String
  warehouseId: String
  dockId: String
  courierName: String
  quantity: Int
}

type SLA {
  id: String
  deliveryChannel: String
  name: String
  deliveryIds: [DeliveryId!]
  shippingEstimate: String
  shippingEstimateDate: String
  lockTTL: String
  price: Int
  listPrice: Int
  tax: Int
  pickupStoreInfo: PickupStoreInfo
  pickupPointId: String
  pickupDistance: Float
  polygonName: String
}

type LogisticsInfoItem {
  itemIndex: Int!
  selectedSla: String!
  lockTTL: String
  price: Int!
  listPrice: Int!
  sellingPrice: Int!
  deliveryCompany: String
  shippingEstimate: String!
  shippingEstimateDate: String!
  deliveryChannel: String!
  addressId: String!
  pickupStoreInfo: PickupStoreInfo!
  pickupPointId: String
  slas: [SLA!]
}

type ShippingData {
  id: String
  logisticsInfo: [LogisticsInfoItem!]
  selectedAddresses: [Address!]
}

type Order {
  orderId: String!
  creationDate: String!
  clientName: String!
  clientProfileData: ClientProfileData
  items: [Item!]!
  comments: [Comment!]
  totalValue: Int!
  status: String!
  statusDescription: String
  sequence: String
  salesChannel: String!
  affiliateId: String
  origin: String
  workflowInErrorState: Boolean
  workflowInRetry: Boolean
  ShippingEstimatedDate: String
  ShippingEstimatedDateMax: String!
  ShippingEstimatedDateMin: String!
  orderIsComplete: Boolean
  authorizedDate: String
  callCenterOperatorName: String
  totalItems: Int
  currencyCode: String
  hostname: String!
  shippingData: ShippingData!
  checkedInPickupPointId: String
  paymentData: PaymentData!
  storePreferencesData: StorePreferencesData!
}

type StorePreferencesData {
  countryCode: String
  currencyCode: String
}

type PaymentData {
  transactions: [Transaction]
}

type Transaction {
  isActive: Boolean
  payments: [Payment]
}

type Payment {
  id: String
  paymentSystem: String!
  paymentSystemName: String!
  value: Int!
  installments: Int
  referenceValue: Int
}

# Inputs

input AddressInput {
  addressId: String!
  addressType: String!
  receiverName: String
  street: String!
  number: String!
  complement: String
  neighborhood: String!
  postalCode: String!
  city: String!
  state: String!
  country: String!
  reference: String
  geoCoordinates: [Float]
}

input PickupStoreInfoInput {
  additionalInfo: String
  address: AddressInput
  dockId: String
  friendlyName: String
  isPickupStore: Boolean!
}

input DeliveryIdInput {
  courierId: String
  warehouseId: String
  dockId: String
  courierName: String
  quantity: Int
}

input SLAInput {
  id: String
  deliveryChannel: String
  name: String
  deliveryIds: [DeliveryIdInput!]
  shippingEstimate: String
  shippingEstimateDate: String
  lockTTL: String
  price: Int
  listPrice: Int
  tax: Int
  pickupStoreInfo: PickupStoreInfoInput
  pickupPointId: String
  pickupDistance: Float
  polygonName: String
}

input LogisticsInfoItemInput {
  itemIndex: Int!
  selectedSla: String!
  lockTTL: String
  price: Int!
  listPrice: Int!
  sellingPrice: Int!
  deliveryCompany: String
  shippingEstimate: String!
  shippingEstimateDate: String!
  deliveryChannel: String!
  addressId: String!
  pickupStoreInfo: PickupStoreInfoInput!
  pickupPointId: String
  slas: [SLAInput!]
}

input AddressTrackingInput {
  street: String
  number: String
  complement: String
  neighborhood: String
  postalCode: String
  city: String
  state: String
  name: String
}

input ShippingDataInput {
  address: AddressTrackingInput
}

input Dimension {
  weight: String
  height: Float
  width: Float
  length: Float
  diameter: Float
}

input Invoice {
  invoiceNumber: String
  invoiceValue: Float
  invoiceSeries: String
}

input Package {
  packageType: String
  dimension: Dimension
  invoice: Invoice
}

input PlpPackage {
  orderId: String
  deliveryServiceId: String
  shippingData: ShippingDataInput
  packages: [Package]
}

type StatusContent {
  status: StatusDescriptionInfo
}

type StatusDescriptionInfo {
  indicator: String
  description: String
}

type Query {
  getExternalStatus: StatusContent @cacheControl(scope: PRIVATE, maxAge: SHORT)
}

# type Mutation {
#   # You should always return the whole object in a mutation, not only a boolean. This will help in browser caching
# }
